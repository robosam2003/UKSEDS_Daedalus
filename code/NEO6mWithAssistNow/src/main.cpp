// Created by Samuel scott (robosam2003) on 30/04/2022
/// Datasheet url: https://content.u-blox.com/sites/default/files/products/documents/u-blox6_ReceiverDescrProtSpec_%28GPS.G6-SW-10018%29_Public.pdf#page=118&zoom=100,0,0
/// little endian format /:)

// This program reads the mgaonline.ubx file from the sd card and then writes it to the NEO6M GPS


#include <Arduino.h>
#include <SPI.h>
#include <SD.h>
#include <TimeLib.h>
#include "assistNow.h"



#define transistorPin 32
#define ubxHeader1 0xB5
#define ubxHeader2 0x62


/// Change this what Serial port the GPS is connected to
#define gpsSerial Serial2 // Hardware serial port for GPS


void sendUbx(byte ubxClassID, byte messageID, short payloadLength, const byte payload[]) { // Send a UBX message
    byte buffer[payloadLength + 8];
    buffer[0] = ubxHeader1;
    buffer[1] = ubxHeader2;
    buffer[2] = ubxClassID;
    buffer[3] = messageID;
    buffer[4] = (payloadLength & 0xFF00) >> 8; // little endian
    buffer[5] = (payloadLength & 0x00FF);
    for (int i = 0; i < payloadLength; i++) {
        buffer[i + 6] = payload[i];
    }
    /// Calculate the checksum
    byte ckBuffer[payloadLength + 4]; // includes ubxClassID, messageID, payloadLength, and payload
    int n = 0;
    uint8_t CK_A= 0, CK_B = 0;
    for (int i=0;i<n;i++)
    {
        CK_A = CK_A + ckBuffer[i];
        CK_B = CK_B + CK_A;
    }
    buffer[payloadLength + 6] = CK_A;
    buffer[payloadLength + 7] = CK_B;
    /// Send the message
    for (int i = 0; i < payloadLength + 8; i++) {
        gpsSerial.write(buffer[i]);
    }

}

void getUbx(byte ubxClassID, byte messageID, short payloadLength, byte payload[]) { // Get a UBX message
    // As a quick aside, this function was generated almost entirely by Github copilot, and I am truly shocked.

    /** The UBX protocol was designed such, that when sending a message with no payload
     (or just a single parameter which identifies the poll request) the
     message is polled.  - Datasheet: 27.2 */

    // Send the poll request with empty payload to poll.
    sendUbx(ubxClassID, messageID, 0, NULL);

    byte buffer[payloadLength + 8];
    for (int i=0;i < payloadLength + 8;i++) {
        buffer[i] = gpsSerial.read();
    }
    /// Check the header
    if (buffer[0] != ubxHeader1 || buffer[1] != ubxHeader2) {
        return;
    }
    /// Check the class ID
    if (buffer[2] != ubxClassID) {
        return;
    }
    /// Check the message ID
    if (buffer[3] != messageID) {
        return;
    }
    /// Check the payload length
    if (buffer[4] != (payloadLength & 0xFF00) >> 8 || buffer[5] != (payloadLength & 0x00FF)) {
        return;
    }
    /// Check the checksum
    byte ckBuffer[payloadLength + 4]; // includes ubxClassID, messageID, payloadLength, and payload
    int n = 0;
    uint8_t CK_A= 0, CK_B = 0;
    for (int i=0;i<n;i++)
    {
        CK_A = CK_A + ckBuffer[i];
        CK_B = CK_B + CK_A;
    }
    if (buffer[payloadLength + 6] != CK_A || buffer[payloadLength + 7] != CK_B) {
        return;
    }
    /// Copy the payload
    for (int i = 0; i < payloadLength; i++) {
        payload[i] = buffer[i + 6];
    }
}

void getUbxFromFile(File fptr, byte ubxClassID, byte messageID, short payloadLength, byte payload[]) {
    int fileSize = fptr.size();
    for (int i=0;i<fileSize;i++) {
        byte b = fptr.read();

        // everything below here is generated by Github copilot - amazing!
        if (b == ubxHeader1) {
            if (fptr.read() == ubxHeader2) {
                if (fptr.read() == ubxClassID) {
                    if (fptr.read() == messageID) {
                        if (fptr.read() == (payloadLength & 0xFF00) >> 8) {
                            if (fptr.read() == (payloadLength & 0x00FF)) {
                                for (int i = 0; i < payloadLength; i++) {
                                    payload[i] = fptr.read();
                                }
                                return;
                            }
                        }
                    }
                }
            }
        }
    }


}

void performOnlineAssist() {
    /** ---------AIDING SEQUENCE--------- Datasheet section 13.5 (pg. 34)
     • Power-up the GPS receiver
     • Send UBX-AID-INI (time, clock and position) message.
     • Send UBX-AID-EPH (ephemeris) message.
     • Apply optional hardware time synchronization pulse within 0.5 s after (or before, depending on the
     configuration in UBX-AID-INI) sending the UBX-AID-INI message if hardware time synchronization is
     required. When sending the message before applying the pulse, make sure to allow the GPS receiver to
     parse and process the aiding message. The time for parsing depends on the baud rate. The processing time
     is 100 ms maximum.
     • Send optional UBX-AID-HUI (health, UTC and ionosphere parameters) message.
     • Send optional UBX-AID-ALM (almanac) message. **/

    if (!SD.begin(BUILTIN_SDCARD)) {
        Serial.println("Could not mount SD card");
        digitalWrite(LED_BUILTIN, HIGH);
        while (true);
    }
    Serial.println("Card initialised");

    // this file ("mgaonline.ubx") should be loaded into the onboard SD card
    // the generator token can be obtained from thingstream from ublocks
    File dataFile = SD.open("mgaonline.ubx");
    const int numbytes = dataFile.available();


    while(dataFile.available()){
        byte b = dataFile.read();
        Serial.print(b, HEX);
        Serial2.write(&b,1);
        Serial2.flush();
    }

    dataFile.close();
    Serial.printf("Successfully read %d bytes and wrote them to the GPS.\n", numbytes);


}


void setup() {
    // turn on the GPS
    pinMode(transistorPin, OUTPUT);
    digitalWrite(transistorPin, HIGH);
    Serial.begin(9600);
    Serial2.begin(9600);


    Serial2.print("$PUBX,40,GLL,0,0,0,0*5C\r\n");
    Serial2.print("$PUBX,40,ZDA,0,0,0,0*44\r\n");
    Serial2.print("$PUBX,40,VTG,0,0,0,0*5E\r\n");
    Serial2.print("$PUBX,40,GSV,0,0,0,0*59\r\n");
    Serial2.print("$PUBX,40,GSA,0,0,0,0*4E\r\n");
    Serial2.print("$PUBX,40,RMC,0,0,0,0*47\r\n");
    Serial2.print("$PUBX,40,GGA,205401,19,04,3.0,50.9,N,042.6,W,1,08,1.0,0.0,M,0.0,M,,");

    Serial2.flush();
    Serial2.clear();
}





void loop() {

    while (Serial2.available() > 0) {
        Serial.write(Serial2.read());
    }


}











/*
#include <Arduino.h>
#include <SoftwareSerial.h>
SoftwareSerial GPS(7, 8);
byte gps_set_sucess = 0 ;


// prototypes
void sendUBX(uint8_t *MSG, uint8_t len);
boolean getUBX_ACK(uint8_t *MSG);
void setup()
{
    GPS.begin(9600);
    // START OUR SERIAL DEBUG PORT
    Serial.begin(9600);
    Serial.println("GPS Level Convertor Board Test Script");
    Serial.println("03/06/2012 2E0UPU");
    Serial.println("Initialising....");
    //
    // THE FOLLOWING COMMAND SWITCHES MODULE TO 4800 BAUD
    // THEN SWITCHES THE SOFTWARE SERIAL TO 4,800 BAUD
    //
    GPS.print("$PUBX,41,1,0007,0003,4800,0*13\r\n");
    GPS.begin(9600);
    GPS.flush();

    //  THIS COMMAND SETS FLIGHT MODE AND CONFIRMS IT
    Serial.println("Setting uBlox nav mode: ");
    uint8_t setNav[] = {
            0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00,
            0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x2C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0xDC };
    while(!gps_set_sucess)
    {
        sendUBX(setNav, sizeof(setNav)/sizeof(uint8_t));
        gps_set_sucess=getUBX_ACK(setNav);
    }
    gps_set_sucess=0;

    // THE FOLLOWING COMMANDS DO WHAT THE $PUBX ONES DO BUT WITH CONFIRMATION
    // UNCOMMENT AS NEEDED
    */
/*
    Serial.println("Switching off NMEA GLL: ");
     uint8_t setGLL[] = {
     0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x2B                   };
     while(!gps_set_sucess)
     {
     sendUBX(setGLL, sizeof(setGLL)/sizeof(uint8_t));
     gps_set_sucess=getUBX_ACK(setGLL);
     }
     gps_set_sucess=0;
     Serial.println("Switching off NMEA GSA: ");
     uint8_t setGSA[] = {
     0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x32                   };
     while(!gps_set_sucess)
     {
     sendUBX(setGSA, sizeof(setGSA)/sizeof(uint8_t));
     gps_set_sucess=getUBX_ACK(setGSA);
     }
     gps_set_sucess=0;
     Serial.println("Switching off NMEA GSV: ");
     uint8_t setGSV[] = {
     0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x39                   };
     while(!gps_set_sucess)
     {
     sendUBX(setGSV, sizeof(setGSV)/sizeof(uint8_t));
     gps_set_sucess=getUBX_ACK(setGSV);
     }
     gps_set_sucess=0;
     Serial.print("Switching off NMEA RMC: ");
     uint8_t setRMC[] = {
     0xB5, 0x62, 0x06, 0x01, 0x08, 0x00, 0xF0, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x40                   };
     while(!gps_set_sucess)
     {
     sendUBX(setRMC, sizeof(setRMC)/sizeof(uint8_t));
     gps_set_sucess=getUBX_ACK(setRMC);
     }
     *//*


}

void loop()
{
    while(1)
    {
        if(GPS.available())
        {
            // THIS IS THE MAIN LOOP JUST READS IN FROM THE GPS SERIAL AND ECHOS OUT TO THE ARDUINO SERIAL.
            Serial.write(GPS.read());
        }

    }
}


// Send a byte array of UBX protocol to the GPS
void sendUBX(uint8_t *MSG, uint8_t len) {
    for(int i=0; i<len; i++) {
        GPS.write(MSG[i]);
        Serial.print(MSG[i], HEX);
    }
    GPS.println();
}


// Calculate expected UBX ACK packet and parse UBX response from GPS
boolean getUBX_ACK(uint8_t *MSG) {
    uint8_t b;
    uint8_t ackByteID = 0;
    uint8_t ackPacket[10];
    unsigned long startTime = millis();
    Serial.print(" * Reading ACK response: ");

    // Construct the expected ACK packet
    ackPacket[0] = 0xB5;	// header
    ackPacket[1] = 0x62;	// header
    ackPacket[2] = 0x05;	// class
    ackPacket[3] = 0x01;	// id
    ackPacket[4] = 0x02;	// length
    ackPacket[5] = 0x00;
    ackPacket[6] = MSG[2];	// ACK class
    ackPacket[7] = MSG[3];	// ACK id
    ackPacket[8] = 0;		// CK_A
    ackPacket[9] = 0;		// CK_B

    // Calculate the checksums
    for (uint8_t i=2; i<8; i++) {
        ackPacket[8] = ackPacket[8] + ackPacket[i];
        ackPacket[9] = ackPacket[9] + ackPacket[8];
    }

    while (1) {

        // Test for success
        if (ackByteID > 9) {
            // All packets in order!
            Serial.println(" (SUCCESS!)");
            return true;
        }

        // Timeout if no valid response in 3 seconds
        if (millis() - startTime > 3000) {
            Serial.println(" (FAILED!)");
            return false;
        }

        // Make sure data is available to read
        if (GPS.available()) {
            b = GPS.read();

            // Check that bytes arrive in sequence as per expected ACK packet
            if (b == ackPacket[ackByteID]) {
                ackByteID++;
                Serial.print(b, HEX);
            }
            else {
                ackByteID = 0;	// Reset and look again, invalid order
            }

        }
    }
}
*/
